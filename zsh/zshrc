#
# .zshrc is sourced in interactive shells.
# It should contain commands to set up aliases,
# functions, options, key bindings, etc.
#
#  Not all terminals support this and, of those that do,
#  not all provide facilities to test the support, hence
#  the user should decide based on the terminal type.  Most
#  terminals  support the  colours  black,  red,  green,
#  yellow, blue, magenta, cyan and white, which can be set
#  by name.  In addition. default may be used to set the
#  terminal's default foreground colour.  Abbreviations
#  are allowed; b or bl selects black.
#
HISTFILE=~/.histfile
HISTSIZE=1000
SAVEHIST=1000

# these substitutions seem to cause problems with tmux AND, with vi-mode seem unnecessary
# WORDCHARS="${WORDCHARS:s#/#}"
# WORDCHARS="${WORDCHARS:s#.#}"

### Setup computer type 
if [[ -f $HOME/.comptype ]] ; then
  export COMP_TYPE=$(sed "1q;d" $HOME/.comptype)
else
  echo "*** Please run the setup.sh script in the dot file directory"
  echo "    things may not run smoothly until this is done. Thank you."
fi

# grab the paths
. $HOME/.path


# get extra source files
sources=("color" "keys" "completion" "profile" "alias" "prompt" "functions")
for file in $sources ; do
  . $HOME/.zsh/$file.zsh
done

# start gpg-agent
. $HOME/.gpg

#I want my umask 0002 if I'm not root
if [[ $(whoami) = root ]]; then
  umask 022
else
  umask 022
fi

# --- systems are go 
if [[ $TERM != dumb ]] ; then

  # now settup terminal multiplexer (the SSH_CONNECTION was originally meant to block the cellphone)
  if [[ ! -n $DISABLE_TMX && ! -n $TMUX  && "$COMP_TYPE" != "central"  &&  ! -n $SSH_CONNECTION ]] ; then
    #if [[ ! -n $TMUX ]] && [[ "$COMP_TYPE" != "central" ]] ; then
    # This checks if tmux exists, and if it does, runs the startup script tmx
    {  hash tmux 2>&- && tmx $(hostname -s) ; } || echo >&2 "tmux did not startup on this machine (is it installed?) ..." 
  fi

  # are we connected through SSH?
  if [[ -n $SSH_CONNECTION ]] ; then 
    ssh_remote_string="${WHITE_BRIGHT} | ${RED}ssh: ${RED_BRIGHT}$(echo $SSH_CLIENT | awk '{print $1}' )"
  else
    ssh_remote_string=""
  fi

  # Welcome message:
  SIGNIN_DATE=$(date "+%Y年 %m月 %d日 （%a）%H:%M:%S")
  print -P "${HASH_MOD2}$(hostname -s): ${WHITE}${SIGNIN_DATE}${ssh_remote_string}${NC}"

  # check if port needs update (3 days outdated)
  if [[ "$COMP_TYPE" == "local" ]] ; then
    portupdateneeded 3
  fi

  # MacPorts autojump
  if [[ $fpath != */opt/local/share/zsh/site-functions* ]] ; then
      export FPATH="$FPATH:/opt/local/share/zsh/site-functions"   
  fi
  if [ -f /opt/local/etc/profile.d/autojump.zsh ]; then         
    . /opt/local/etc/profile.d/autojump.zsh                   
  fi                                                           
  if [ -f $HOME/local/bin/autojump.zsh ] ; then
    . $HOME/local/bin/autojump.zsh
  fi

  # auto extra zsh completion files
  if [[ $fpath != *.zsh/Completion* ]] ; then
    fpath=(~/.zsh/Completion $fpath)
  fi

fi

# This is a command that pipes all stderr to a red filter :)
# Compliments: http://skinwalker.wordpress.com/2012/01/24/stderr-zsh/

#if [[ -f $HOME/.rcbundles/stderred/build/libstderred.dylib ]] ; then
  ## export DYLD_INSERT_LIBRARIES=$HOME/dev/github_third-party/stderred/lib/stderred.dylib 
  ## export DYLD_FORCE_FLAT_NAMESPACE=1

  #export DYLD_INSERT_LIBRARIES="$HOME/.rcbundles/stderred/build/libstderred.dylib${DYLD_INSERT_LIBRARIES:+:$DYLD_INSERT_LIBRARIES}"
  #export STDERRED_ESC_CODE=$ERROR_RED
#else
  #echo "${ERROR_RED}*** stderr is being piped to red output: may cause strange behavior"
  #exec 2>>( while read X; do print "${ERROR_RED}${X}${NC}" > /dev/tty; done & )
#fi

